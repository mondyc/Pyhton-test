'''属性和方法'''

# Python中一切皆对象
# 即使用class 定义的类也是一个对象

# 对象的划分
'''
    实例对象（实例）
1．通过类名()创建的对象，我们称为实例对象，简称实例
2．创建对象的过程称为是类的实例化
3．我们平时所说的对象就是指实例对象(实例)
4．每个实例对象，都有自己的内存空间，在自己的内存空间中保存自己的属性

    类对象（类）
1．类对象就是类,或者可以认为是类名
2．类对象是 Python_解释器在执行代码的过程中创建的
3．类对象的作用:
    ①土使用类对象创建实例类名()
    ②类对象也有自己的内存空间，可以保存一些属性值信息(类属性)
4．在一个代码中，一个类只有一份内存空间
'''

# 属性的划分
'''
实例属性
概念：是实例对象具有的属性
定义和使用:
    在init方法中，使用 self.属性名 = 属性值 定义
    在方法中是使用 self.属性名 来获取(调用)
内存：实例属性,在每个实例中都存在一份
使用时机：
    1．基本上99%都是实例属性,即通过self去定义
    2．找多个对象，来判断这个值是不是都是一样的，如果都是一样的，同时变化，则一般定义为类属性，否则定义为实例属性

类属性
概念：是类对象具有的属性
定义和使用:
    在类内部，方法外部，直接定义的变量，就是类属性
使用：
    类对象.属性名 = 属性值 or 类名.属性名=属性值
    类对象.属性名 or 类名.属性名
内存：只有类对象中存在一份
'''

print('-----------------------------------------------------------')


# 案例

# 定义一个Dog类，定义一个类属性 count，用来记录创建该类对象的个数．
# (即每创建一个对象，count的值就要加1)实例属性name

class Dog:
    # 定义类属性
    count = 0

    # 定义实例属性，init方法中
    def __init__(self, name):
        self.name = name  # 实例属性
        # 因为每创建一个对象,就会调用init方法，就将个数加1的操作，写在init方法中
        Dog.count = Dog.count + 1


# 在类外部
# 打印输出目前创建几个对象
print(Dog.count)  # 0
# #创建—个对象
dog1 = Dog('小花')
# 打印输出目前创建几个对象
print(Dog.count)  # 1
dog2 = Dog  # 不是创建对象，个数不变的
dog3 = dog1  # 不是创建对象，个数不变的
print(Dog.count)  # 1

dog4 = Dog('大黄')  # 创建一个对象，个数+1
print(Dog.count)  # 2
dog5 = Dog('小白')
print(Dog.count)  # 3

# 补充，可以使用实例对象.类属性名来获取类属性的值﹐
# （原因，实例对象属性的查找顺序，先在实例属性中找,找到直接使用
# #没有找到会去类属性中找,找到了可以使用,没有找到报错)
print(dog1.count)  # 3
print(dog4.count)  # 3
print(dog5.count)  # 3

print('-----------------------------------------------------------')


# 方法的划分
# 方法，使用 def 关键字定义在类中的函数就是方法

# 实例方法(最常用)
# 定义：
# 在类中直接定义的方法就是实例方法class Demo :
class Demo:
    def func(self):  # 参数一般写作self,表示的是实例对象
        pass


# 定义时机(什么时候用)：
# 如果在方法中需要使用实例属性(即需要使用self)，则这个方法必须定义为实例方法
# 调用：
# 对象.方法名()


# 类方法(会用)
# 定义：
# 在方法名字的上方书写@classmethod 装饰器(使用@classmethod装饰的方法)
class Demo:
    @classmethod
    def func(cls):  # 参数―般写作cls，表示的是类对象(即类名) class
        pass


# 定义时机(什么时候用)
# 1．前提，方法中不需要使用实例属性(即self)
# 2．用到了类属性，可以将这个方法定义为类方法，(也可以定义为实例方法)
# 调用：
# 1．通过类对象调用
# 类名.方法名() # 也不需要给cls传参，python解释器自动传递
# 2．通过实例对象调用
# 实例.方法名() # 也不需要给cls传参，python解释器自动传递


# 静态方法(基本不用)
# 定义
# 在方法名字的上方书写@staticmethod装饰器(使用@staticmethod装饰的方法)
class Demo:
    @staticmethod
    def func():
        pass


# 定义时机(什么时候用)
# 1．前提，方法中不需要使用实例属性(即self)
# 2．也不使用类属性，可以将这个方法定义为静态方法
# 调用
# 1．通过类对象调用类名.方法名()
# 2．通过实例对象调用实例.方法名()
'''
题目2
定义一个游戏类Game，包含实例属性玩家名字(name)
1．要求记录游戏的最高分(top_score类属性)
2.定义方法: show_help显示游戏的帮助信息输出这是游戏的帮助信息
3.定义方法: show_top_score,打印输出游戏的最高分
4.定义方法: start _game，开始游戏,规则如下
    1．使用随机数获取本次游戏得分范围(10-100)之间
    2.判断本次得分和最高分之间的关系
        如果本次得分比最高分高，
            修改最高分
        如果分数小于等于最高分,则不操作
    3．输出本次游戏得分
5．主程序步骤
    # 1)创建一个Game对象小王
    # 2)小王玩一次游戏
    # 3)查看历史最高分
    # 4)小王再玩一次游戏
    # 5)查看历史最高分
    # 6)查看游戏的帮助信息
'''
import random


class Game:
    # 类属性，游戏的最高分
    top_score = 0

    def __init__(self, name):
        # 定义实例属性 name
        self.name = name

    # 以下是通过优化的代码
    @staticmethod  # 静态方法
    def show_help():
        print('这是游戏的帮助信息')

    @classmethod  # 类方法
    def show_top_score(cls):
        print(f'游戏的最高分为{cls.top_score}')

    # 以上是通过优化的代码

    def start_game(self):
        print(f'{self.name}开始一局游戏')
        score = random.randint(10, 100)  # 本次游戏得分
        print(f'本次，游戏得分为{score}')
        if score > Game.top_score:
            # 修改最高分
            Game.top_score = score


xw = Game('小王')
xw.start_game()
xw.show_top_score()
xw.start_game()
xw.show_top_score()
xw.show_help()

print('-----------------------------------------------------------')

# 补充
# 哈希(hash):是一个算法，可以对数据产生一个唯一的值(指纹)

# is 可以用来判断两个对象是不是同一个对象，即两个对象的引用是否相同
# a is b ===> id(a) == id(b)
# 面试中可能会问: is 和 == 的区别？
# == 只判断数据值是否相同，is判断引用是否相同
